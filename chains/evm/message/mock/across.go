// Code generated by MockGen. DO NOT EDIT.
// Source: ./chains/evm/message/across.go
//
// Generated by this command:
//
//	mockgen -source=./chains/evm/message/across.go -destination=./chains/evm/message/mock/across.go
//

// Package mock_message is a generated GoMock package.
package mock_message

import (
	context "context"
	big "math/big"
	reflect "reflect"

	ethereum "github.com/ethereum/go-ethereum"
	common "github.com/ethereum/go-ethereum/common"
	types "github.com/ethereum/go-ethereum/core/types"
	peer "github.com/libp2p/go-libp2p/core/peer"
	events "github.com/sprintertech/sprinter-signing/chains/evm/calls/events"
	tss "github.com/sprintertech/sprinter-signing/tss"
	gomock "go.uber.org/mock/gomock"
)

// MockEventFilterer is a mock of EventFilterer interface.
type MockEventFilterer struct {
	ctrl     *gomock.Controller
	recorder *MockEventFiltererMockRecorder
	isgomock struct{}
}

// MockEventFiltererMockRecorder is the mock recorder for MockEventFilterer.
type MockEventFiltererMockRecorder struct {
	mock *MockEventFilterer
}

// NewMockEventFilterer creates a new mock instance.
func NewMockEventFilterer(ctrl *gomock.Controller) *MockEventFilterer {
	mock := &MockEventFilterer{ctrl: ctrl}
	mock.recorder = &MockEventFiltererMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventFilterer) EXPECT() *MockEventFiltererMockRecorder {
	return m.recorder
}

// FilterLogs mocks base method.
func (m *MockEventFilterer) FilterLogs(ctx context.Context, q ethereum.FilterQuery) ([]types.Log, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FilterLogs", ctx, q)
	ret0, _ := ret[0].([]types.Log)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FilterLogs indicates an expected call of FilterLogs.
func (mr *MockEventFiltererMockRecorder) FilterLogs(ctx, q any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FilterLogs", reflect.TypeOf((*MockEventFilterer)(nil).FilterLogs), ctx, q)
}

// LatestBlock mocks base method.
func (m *MockEventFilterer) LatestBlock() (*big.Int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LatestBlock")
	ret0, _ := ret[0].(*big.Int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LatestBlock indicates an expected call of LatestBlock.
func (mr *MockEventFiltererMockRecorder) LatestBlock() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LatestBlock", reflect.TypeOf((*MockEventFilterer)(nil).LatestBlock))
}

// TransactionReceipt mocks base method.
func (m *MockEventFilterer) TransactionReceipt(ctx context.Context, txHash common.Hash) (*types.Receipt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TransactionReceipt", ctx, txHash)
	ret0, _ := ret[0].(*types.Receipt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TransactionReceipt indicates an expected call of TransactionReceipt.
func (mr *MockEventFiltererMockRecorder) TransactionReceipt(ctx, txHash any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TransactionReceipt", reflect.TypeOf((*MockEventFilterer)(nil).TransactionReceipt), ctx, txHash)
}

// MockCoordinator is a mock of Coordinator interface.
type MockCoordinator struct {
	ctrl     *gomock.Controller
	recorder *MockCoordinatorMockRecorder
	isgomock struct{}
}

// MockCoordinatorMockRecorder is the mock recorder for MockCoordinator.
type MockCoordinatorMockRecorder struct {
	mock *MockCoordinator
}

// NewMockCoordinator creates a new mock instance.
func NewMockCoordinator(ctrl *gomock.Controller) *MockCoordinator {
	mock := &MockCoordinator{ctrl: ctrl}
	mock.recorder = &MockCoordinatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCoordinator) EXPECT() *MockCoordinatorMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockCoordinator) Execute(ctx context.Context, tssProcesses []tss.TssProcess, resultChn chan any, coordinator peer.ID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute", ctx, tssProcesses, resultChn, coordinator)
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute.
func (mr *MockCoordinatorMockRecorder) Execute(ctx, tssProcesses, resultChn, coordinator any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockCoordinator)(nil).Execute), ctx, tssProcesses, resultChn, coordinator)
}

// MockConfirmationWatcher is a mock of ConfirmationWatcher interface.
type MockConfirmationWatcher struct {
	ctrl     *gomock.Controller
	recorder *MockConfirmationWatcherMockRecorder
	isgomock struct{}
}

// MockConfirmationWatcherMockRecorder is the mock recorder for MockConfirmationWatcher.
type MockConfirmationWatcherMockRecorder struct {
	mock *MockConfirmationWatcher
}

// NewMockConfirmationWatcher creates a new mock instance.
func NewMockConfirmationWatcher(ctrl *gomock.Controller) *MockConfirmationWatcher {
	mock := &MockConfirmationWatcher{ctrl: ctrl}
	mock.recorder = &MockConfirmationWatcherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConfirmationWatcher) EXPECT() *MockConfirmationWatcherMockRecorder {
	return m.recorder
}

// WaitForOrderConfirmations mocks base method.
func (m *MockConfirmationWatcher) WaitForOrderConfirmations(ctx context.Context, chainID uint64, txHash common.Hash, orderValue float64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WaitForOrderConfirmations", ctx, chainID, txHash, orderValue)
	ret0, _ := ret[0].(error)
	return ret0
}

// WaitForOrderConfirmations indicates an expected call of WaitForOrderConfirmations.
func (mr *MockConfirmationWatcherMockRecorder) WaitForOrderConfirmations(ctx, chainID, txHash, orderValue any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForOrderConfirmations", reflect.TypeOf((*MockConfirmationWatcher)(nil).WaitForOrderConfirmations), ctx, chainID, txHash, orderValue)
}

// WaitForTokenConfirmations mocks base method.
func (m *MockConfirmationWatcher) WaitForTokenConfirmations(ctx context.Context, chainID uint64, txHash common.Hash, token common.Address, amount *big.Int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WaitForTokenConfirmations", ctx, chainID, txHash, token, amount)
	ret0, _ := ret[0].(error)
	return ret0
}

// WaitForTokenConfirmations indicates an expected call of WaitForTokenConfirmations.
func (mr *MockConfirmationWatcherMockRecorder) WaitForTokenConfirmations(ctx, chainID, txHash, token, amount any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForTokenConfirmations", reflect.TypeOf((*MockConfirmationWatcher)(nil).WaitForTokenConfirmations), ctx, chainID, txHash, token, amount)
}

// MockDepositFetcher is a mock of DepositFetcher interface.
type MockDepositFetcher struct {
	ctrl     *gomock.Controller
	recorder *MockDepositFetcherMockRecorder
	isgomock struct{}
}

// MockDepositFetcherMockRecorder is the mock recorder for MockDepositFetcher.
type MockDepositFetcherMockRecorder struct {
	mock *MockDepositFetcher
}

// NewMockDepositFetcher creates a new mock instance.
func NewMockDepositFetcher(ctrl *gomock.Controller) *MockDepositFetcher {
	mock := &MockDepositFetcher{ctrl: ctrl}
	mock.recorder = &MockDepositFetcherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDepositFetcher) EXPECT() *MockDepositFetcherMockRecorder {
	return m.recorder
}

// Deposit mocks base method.
func (m *MockDepositFetcher) Deposit(ctx context.Context, hash common.Hash, depositID *big.Int) (*events.AcrossDeposit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Deposit", ctx, hash, depositID)
	ret0, _ := ret[0].(*events.AcrossDeposit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Deposit indicates an expected call of Deposit.
func (mr *MockDepositFetcherMockRecorder) Deposit(ctx, hash, depositID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deposit", reflect.TypeOf((*MockDepositFetcher)(nil).Deposit), ctx, hash, depositID)
}
